Static, Annotation, 상속, Final, 다형성
==========================
## :wrench: Static
* 클래스에 고정된 필드와 메소드: 정적필드, 정적메소드

* 정적멤버는 클래스에 소속된 멤버
> 객체 내부에 존재하지 않고 메소드영역 존재
> 정적 멤버는 객체를 생성하지 않고 클래스에 바로 접근해 사용

* 정적 초기화 블록
> 클래스가 메소드 영역으로 로딩될 때 자동으로 실행하는 블록
```
static {
// 초기화 할 내용
}
```
## :wrench:  Annotation(어노테이션)
* Annotation 정의
> 프로그램에게 추가적인 정보를 제공해주는 메타데이터
* Metadata 정의
> 데이터를 설명해주는 데이터
>> 컴파일 과정과 실행과정에서 어떻게 컴파일하고, 처리할 것인지를 알려주는 정보
## :wrench:  상속
* 상속의 정의
> 객체의 필드(변수)와 메소드를 다른객체가 물려 받을 수 있는 기능

* 상속의 사용
> 자식클래스가 부모클래스의 필드와 메소드 뿐만아니라 추가적인 기능이 필요할 때 사용

* 상속 대상 제한
> 부모클래스의 private 접근 갖는 필드, 메소드 제외
> 부모클래스가 다른 패키지에 있을 경우 (default 제외)

* 클래스 상속
> 문법
>> 자식클래스 extends 부모클래스

* 자바는 단일 상속 - 부모 클래스 나열 불가
```
class 자식클래스 extends 부모클래스1, 부모클래스2 {
	// 부모클래스 2 기입불가능
}
```

* super()
> 반드시 자식 생성자의 첫 줄에 위치
>> 부모클래스에 default 생성자가 없다면 필수 작성
>>> 부모 객체 생성 시 부모 생성자를 선택하여 호출

* 메소드 재정의 (@Override)
Override 정의
> 부모 클래스의 상속 메소드를 수정하여 자식 클래스에서 재정의 하는 것

* 메소드 재정의 조건
1. 접근제한을 더 강하게 오버라이딩 할 수 없음
> public를 default, private로 수정 할 수 없음  
2. 새로운 예외 처리 불가

* 메소드 재정의 효과
> 부모 메소드는 숨겨지는 효과 발생

* 부모 메소드 사용
> super.부모메소드();

## :wrench:  final클래스, final 메소드
* final 키워드의 용도
> final 필드 : 수정 불가 필드
> final 클래스 : 부모로 사용할 수 없는 클래스
> final 메소드 : 자식이 재정의 할 수 없는 메소드

## :wrench:   다형성 (Polymorphism)
* 다형성의 정의
> 같은 타입이지만 실행 결과가 다양한 객체 대입이 가능한 성질
>> 부모 타입에는 모든 자식 객체가 대입 가능
>>> 자식 타입은 부모 타입으로 자동 타입 변환

* 강제 타입 변환(Casting)
조건
> 자식 타입을 부모 타입으로 자동 변환 후 다시 자식 타입으로 변환할 때만 유효함

필요한경우
> 자식 타입이 부모 타입으로 자동 변환되면 부모 타입에 선언된 필드, 메소드 사용가능

* 객체 타입 확인(instanceof)
강제 타입 변환 가능 여부 확인법
```
boolean result = 객체 instanceof 클래스 // 객체가 타입으로부터 생성됬는지 확인하여 true / false 반환
```
